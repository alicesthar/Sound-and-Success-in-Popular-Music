# ---- 5) CLEAN + SONG-LEVEL TABLE (2000–2018) --------------------------------
message("STEP 2: Creating Song-Level Dataset (2000–2018)...")
# Chart summary inside 2000–2018 only (so weeks_on_chart is within your window)
chart_summary_0018 <- df_chart %>%
filter(week >= as.Date("2000-01-01"), week <= as.Date("2018-12-31")) %>%
group_by(song_id) %>%
summarise(
weeks_on_chart = n(),
peak_position  = min(peak_position, na.rm = TRUE),
.groups = "drop"
)
df_final <- chart_summary_0018 %>%
inner_join(df_audio, by = "song_id") %>%
inner_join(df_pop, by = "song_id") %>%
filter(year >= 2000 & year <= 2018) %>%
transmute(
song_id,
year,
popularity = year_end_score,
weeks_on_chart,
peak_position,
danceability, energy, valence, acousticness, loudness, tempo
) %>%
drop_na()
message(paste("Final Dataset Rows:", nrow(df_final)))
# Normalise features (0–1) for comparability and clustering
min_max <- function(x) (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
model_data <- df_final %>%
mutate(across(c(danceability, energy, valence, acousticness, loudness, tempo), min_max))
# Define "Hit" threshold (Top 25% popularity within your analysis dataset)
pop_thresh <- quantile(model_data$popularity, 0.75, na.rm = TRUE)
model_data <- model_data %>%
mutate(is_hit = factor(if_else(popularity >= pop_thresh, "Hit", "Non-Hit")))
# Save a clean dataset for reproducibility / appendix
write_csv(model_data, "outputs/data_clean_model_data_2000_2018.csv")
# ==============================================================================
# FIGURE 1 (EDA): Popularity distribution + hit threshold
# ==============================================================================
message("STEP 3: Figure 1 (EDA Popularity)...")
p_fig1 <- ggplot(model_data, aes(x = popularity)) +
geom_histogram(bins = 40, alpha = 0.85, color = "white") +
geom_vline(xintercept = pop_thresh, linetype = "dashed", linewidth = 1) +
labs(
title = "Figure 1: Distribution of Popularity Scores (2000–2018)",
subtitle = "Dashed line marks the Top 25% threshold used to define Hit songs.",
x = "Popularity score (year_end_score)",
y = "Number of songs"
)
ggsave("plots_final/Fig1_EDA_Popularity.png", p_fig1, width = 8, height = 5)
print(p_fig1)
# ==============================================================================
# RQ1: SEASONALITY (FIXED) — Peak week within 2000–2018, then Summer vs Winter
# ==============================================================================
message("STEP 4: RQ1 Seasonality (Peak week fix + t-test if possible)...")
# IMPORTANT FIX:
# Compute peak chart week for each song INSIDE 2000–2018, based on best weekly rank_score (1 is best).
df_chart_0018 <- df_chart %>%
filter(week >= as.Date("2000-01-01"),
week <= as.Date("2018-12-31")) %>%
filter(!is.na(rank_score), !is.na(week))
peak_week_0018 <- df_chart_0018 %>%
group_by(song_id) %>%
arrange(rank_score, week) %>%  # rank_score: 1 best
slice(1) %>%
ungroup() %>%
transmute(song_id, peak_week_date = week)
rq1_data <- model_data %>%
left_join(peak_week_0018, by = "song_id") %>%
drop_na(peak_week_date) %>%
mutate(
peak_month = month(peak_week_date),
Season = case_when(
peak_month %in% c(6, 7, 8)  ~ "Summer",
peak_month %in% c(12, 1, 2) ~ "Winter",
TRUE ~ NA_character_
)
)
seasonal_hits <- rq1_data %>%
filter(is_hit == "Hit", !is.na(Season)) %>%
mutate(Season = factor(Season, levels = c("Summer", "Winter"))) %>%
droplevels()
# Diagnostics to help you (and to mention in Methods if needed)
diag_season_counts <- seasonal_hits %>% count(Season)
diag_month_counts  <- seasonal_hits %>% count(peak_month, sort = TRUE)
write_csv(diag_season_counts, "outputs/RQ1_season_counts.csv")
write_csv(diag_month_counts, "outputs/RQ1_peak_month_counts.csv")
message("RQ1: Season counts:")
print(diag_season_counts)
message("RQ1: Peak-month counts (hits only):")
print(diag_month_counts)
# Plot (always safe even if one season)
p_fig2_rq1 <- ggplot(seasonal_hits, aes(x = Season, y = energy, fill = Season)) +
geom_boxplot(alpha = 0.85, outlier.shape = NA) +
geom_jitter(width = 0.15, alpha = 0.05) +
labs(
title = "Figure 2 (RQ1): Seasonal comparison of Energy for Hit songs",
subtitle = "Hit songs are defined as Top 25% popularity. Seasons based on each song’s peak chart week (2000–2018).",
x = NULL,
y = "Energy (min–max normalised, 0–1)"
) +
theme(legend.position = "none")
ggsave("plots_final/Fig2_RQ1_SeasonalEnergy.png", p_fig2_rq1, width = 8, height = 6)
print(p_fig2_rq1)
# Run t-test ONLY if there are exactly 2 season levels present
tt_out <- NULL
if (nlevels(seasonal_hits$Season) == 2 && all(levels(droplevels(seasonal_hits$Season)) %in% c("Summer", "Winter"))) {
tt_out <- t.test(energy ~ Season, data = seasonal_hits)
message("RQ1 t-test result:")
print(tt_out)
# Save tidy t-test for report table
tt_tbl <- broom::tidy(tt_out)
write_csv(tt_tbl, "outputs/RQ1_ttest_energy_summer_vs_winter.csv")
} else {
message("RQ1 NOTE: Only one season present after filtering (cannot run t-test).")
message("You can still report the seasonal distribution + boxplot, but avoid inferential claims.")
}
# ==============================================================================
# RQ2: LOGISTIC REGRESSION (CLASSIFICATION)
# ==============================================================================
message("STEP 5: RQ2 Logistic Regression (Hit vs Non-Hit)...")
model_rq2 <- glm(
is_hit ~ danceability + energy + valence + acousticness + loudness + tempo,
data = model_data,
family = "binomial"
)
coefs_rq2 <- broom::tidy(model_rq2, conf.int = TRUE) %>%
filter(term != "(Intercept)") %>%
mutate(
OddsRatio = exp(estimate),
OR_low = exp(conf.low),
OR_high = exp(conf.high),
Effect = if_else(OddsRatio >= 1, "Increases odds", "Decreases odds"),
Feature = term
) %>%
arrange(desc(OddsRatio))
write_csv(coefs_rq2, "outputs/RQ2_logistic_odds_ratios.csv")
p_fig3_rq2 <- ggplot(coefs_rq2, aes(x = reorder(Feature, OddsRatio), y = OddsRatio, fill = Effect)) +
geom_col(width = 0.7, alpha = 0.9) +
geom_errorbar(aes(ymin = OR_low, ymax = OR_high), width = 0.2) +
geom_hline(yintercept = 1, linetype = "dashed") +
coord_flip() +
geom_text(aes(label = round(OddsRatio, 2)), hjust = -0.15, size = 4) +
labs(
title = "Figure 3 (RQ2): Acoustic drivers of Hit status (Logistic regression)",
subtitle = "Bars show Odds Ratios (OR) with 95% CIs. OR > 1 increases odds of being a Hit (Top 25% popularity).",
x = NULL,
y = "Odds Ratio (exp(coefficient))"
)
ggsave("plots_final/Fig3_RQ2_OddsRatios.png", p_fig3_rq2, width = 9, height = 6)
print(p_fig3_rq2)
# ==============================================================================
# RQ3: CLUSTERING (HITS ONLY) — K-Means + PCA plot
# ==============================================================================
message("STEP 6: RQ3 Clustering (Hits only)...")
hits_data <- model_data %>% filter(is_hit == "Hit")
cluster_features <- hits_data %>% select(danceability, energy, valence, acousticness, loudness, tempo)
# Select k via silhouette (2–6)
k_grid <- 2:6
sil_scores <- map_dbl(k_grid, function(k) {
km <- kmeans(cluster_features, centers = k, nstart = 50)
mean(silhouette(km$cluster, dist(cluster_features))[, 3])
})
best_k <- k_grid[which.max(sil_scores)]
sil_tbl <- tibble(k = k_grid, silhouette = sil_scores)
write_csv(sil_tbl, "outputs/RQ3_silhouette_scores.csv")
message(paste("RQ3 best k (silhouette):", best_k))
final_km <- kmeans(cluster_features, centers = best_k, nstart = 50)
hits_data <- hits_data %>% mutate(Cluster = factor(final_km$cluster))
# PCA for visualisation (on already normalised features)
pca_res <- prcomp(cluster_features, center = TRUE, scale. = TRUE)
pca_plot <- as.data.frame(pca_res$x[, 1:2]) %>%
mutate(Cluster = hits_data$Cluster)
# Cluster profile (for report table)
cluster_profile <- hits_data %>%
group_by(Cluster) %>%
summarise(
n = n(),
across(c(danceability, energy, valence, acousticness, loudness, tempo), mean),
.groups = "drop"
)
write_csv(cluster_profile, "outputs/RQ3_cluster_profiles.csv")
# Figure 4A: PCA scatter
p_rq3_map <- ggplot(pca_plot, aes(x = PC1, y = PC2, color = Cluster)) +
geom_point(alpha = 0.6, size = 2) +
stat_ellipse(aes(fill = Cluster), geom = "polygon", alpha = 0.10, level = 0.90, show.legend = FALSE) +
labs(
title = "Figure 4 (RQ3): Acoustic archetypes among Hit songs",
subtitle = paste0("K-Means clustering (k=", best_k, ") visualised using PCA (PC1 vs PC2)."),
x = "Principal Component 1",
y = "Principal Component 2"
)
ggsave("plots_final/Fig4_RQ3_Clusters_PCA.png", p_rq3_map, width = 8, height = 6)
print(p_rq3_map)
# Optional: Figure 4B cluster profile bars (often makes RQ3 MUCH clearer)
profile_long <- cluster_profile %>%
select(-n) %>%
pivot_longer(-Cluster, names_to = "Feature", values_to = "Mean") %>%
mutate(Feature = str_to_title(Feature))
p_rq3_profile <- ggplot(profile_long, aes(x = Feature, y = Mean, fill = Cluster)) +
geom_col(position = "dodge", alpha = 0.9) +
coord_flip() +
labs(
title = "Figure 5 (RQ3): Cluster profiles (mean feature values)",
subtitle = "Interpretable summary of how clusters differ across acoustic dimensions (hits only).",
x = NULL,
y = "Mean (0–1 normalised)"
)
ggsave("plots_final/Fig5_RQ3_ClusterProfiles.png", p_rq3_profile, width = 9, height = 6)
print(p_rq3_profile)
message("DONE ✅ Plots saved in 'plots_final/' and tables saved in 'outputs/'.")
# ==============================================================================
# Module: IJC437 Introduction to Data Science
# Coursework: The Mechanics of Musical Success
# Student ID: 25196971
# ==============================================================================
graphics.off()
rm(list = ls())
# 1. SETUP & LIBRARIES ---------------------------------------------------------
pkgs <- c("tidyverse", "scales", "broom", "cluster", "patchwork", "lubridate")
to_install <- pkgs[!sapply(pkgs, require, character.only = TRUE)]
if(length(to_install) > 0) install.packages(to_install)
library(tidyverse)
library(scales)
library(broom)
library(cluster)
library(patchwork)
library(lubridate)
set.seed(2026)
if (!dir.exists("plots_final")) dir.create("plots_final")
if (!dir.exists("outputs")) dir.create("outputs")
# Professional Theme
theme_set(theme_minimal(base_size = 14) +
theme(plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
plot.subtitle = element_text(size = 12, color = "grey40"),
legend.position = "top"))
# 2. DATA LOADING & CLEANING ---------------------------------------------------
load_music_file <- function(filename) {
readr::read_delim(filename, delim = ",", quote = "", comment = "",
na = c("", "NA", "-"), trim_ws = TRUE, show_col_types = FALSE)
}
if(file.exists("data_raw/song_chart.csv")) {
df_chart <- load_music_file("data_raw/song_chart.csv")
df_pop   <- load_music_file("data_raw/song_pop.csv")
df_audio <- load_music_file("data_raw/acoustic_features.csv")
} else { stop("ERROR: 'data_raw' folder missing.") }
# Normalisation Function
min_max <- function(x) (x - min(x, na.rm=T)) / (max(x, na.rm=T) - min(x, na.rm=T))
# ==============================================================================
# RQ1: SEASONAL ANALYSIS (The Superior "Peak Week" Method)
# Question: Are Summer hits significantly more energetic than Winter hits?
# ==============================================================================
message("Generating RQ1 (Seasonality based on Peak Week)...")
# 1. Isolate the Charting Data (2000-2018)
df_chart_0018 <- df_chart %>%
filter(week >= as.Date("2000-01-01"), week <= as.Date("2018-12-31")) %>%
filter(!is.na(rank_score), !is.na(week))
# ==============================================================================
# Module: IJC437 Introduction to Data Science
# Coursework: The Mechanics of Musical Success
# Student ID: 25196971
# ==============================================================================
graphics.off()
rm(list = ls())
# 1. SETUP & LIBRARIES ---------------------------------------------------------
pkgs <- c("tidyverse", "scales", "broom", "cluster", "patchwork", "lubridate")
to_install <- pkgs[!sapply(pkgs, require, character.only = TRUE)]
if(length(to_install) > 0) install.packages(to_install)
library(tidyverse)
library(scales)
library(broom)
library(cluster)
library(patchwork)
library(lubridate)
set.seed(2026)
if (!dir.exists("plots_final")) dir.create("plots_final")
# Professional Theme
theme_set(theme_minimal(base_size = 14) +
theme(plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
plot.subtitle = element_text(size = 12, color = "grey40"),
legend.position = "top"))
# 2. DATA LOADING --------------------------------------------------------------
load_music_file <- function(filename) {
readr::read_delim(filename, delim = ",", quote = "", comment = "",
na = c("", "NA", "-"), trim_ws = TRUE, show_col_types = FALSE)
}
if(file.exists("data_raw/song_chart.csv")) {
df_chart <- load_music_file("data_raw/song_chart.csv")
df_pop   <- load_music_file("data_raw/song_pop.csv")
df_audio <- load_music_file("data_raw/acoustic_features.csv")
} else { stop("ERROR: 'data_raw' folder missing. Check your directory.") }
# Normalisation Helper
min_max <- function(x) (x - min(x, na.rm=T)) / (max(x, na.rm=T) - min(x, na.rm=T))
# ==============================================================================
# RQ1: SEASONAL ANALYSIS (Fixed Date Logic)
# Question: Are Summer hits significantly more energetic than Winter hits?
# ==============================================================================
message("Generating RQ1 (Seasonality based on Peak Week)...")
# 1. Fix Dates and Filter Range
df_chart_0018 <- df_chart %>%
mutate(week = as.Date(week)) %>% # <--- FIXED: Converts text to Date format
filter(week >= as.Date("2000-01-01"), week <= as.Date("2018-12-31")) %>%
filter(!is.na(peak_position), !is.na(week))
# ==============================================================================
# Module: IJC437 Introduction to Data Science
# Coursework: The Mechanics of Musical Success (DISTINCTION PATH)
# Student ID: 25196971
# ==============================================================================
graphics.off()
rm(list = ls())
# 1. SETUP & LIBRARIES ---------------------------------------------------------
pkgs <- c("tidyverse", "scales", "broom", "lubridate", "patchwork")
to_install <- pkgs[!sapply(pkgs, require, character.only = TRUE)]
if(length(to_install) > 0) install.packages(to_install)
library(tidyverse)
library(scales)
library(broom)
library(lubridate)
library(patchwork)
set.seed(2026)
if (!dir.exists("plots_final")) dir.create("plots_final")
# Professional Theme
theme_set(theme_minimal(base_size = 14) +
theme(plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
plot.subtitle = element_text(size = 12, color = "grey40"),
legend.position = "top"))
# 2. DATA LOADING & PREP -------------------------------------------------------
load_music_file <- function(filename) {
readr::read_delim(filename, delim = ",", quote = "", comment = "",
na = c("", "NA", "-"), trim_ws = TRUE, show_col_types = FALSE)
}
if(file.exists("data_raw/song_chart.csv")) {
df_chart <- load_music_file("data_raw/song_chart.csv")
df_pop   <- load_music_file("data_raw/song_pop.csv")
df_audio <- load_music_file("data_raw/acoustic_features.csv")
} else { stop("ERROR: 'data_raw' folder missing.") }
# Normalisation Helper
min_max <- function(x) (x - min(x, na.rm=T)) / (max(x, na.rm=T) - min(x, na.rm=T))
message("STEP 1: Calculating Song Metrics...")
# CALCULATE 'WEEKS ON CHART' (Longevity)
song_longevity <- df_chart %>%
group_by(song_id) %>%
summarise(
Weeks_Charted = n(),             # How long it survived
Peak_Pos = min(peak_position, na.rm=T), # Best rank (1 is best)
First_Week = min(as.Date(week))  # Release date proxy
) %>%
mutate(Year = year(First_Week)) %>%
filter(Year >= 2000 & Year <= 2018)
# ==============================================================================
# Module: IJC437 Introduction to Data Science
# Coursework: The Mechanics of Musical Success (DISTINCTION PATH)
# Student ID: 25196971
# ==============================================================================
graphics.off()
rm(list = ls())
# 1. SETUP & LIBRARIES ---------------------------------------------------------
pkgs <- c("tidyverse", "scales", "broom", "lubridate", "patchwork")
to_install <- pkgs[!sapply(pkgs, require, character.only = TRUE)]
if(length(to_install) > 0) install.packages(to_install)
library(tidyverse)
library(scales)
library(broom)
library(lubridate)
library(patchwork)
set.seed(2026)
if (!dir.exists("plots_final")) dir.create("plots_final")
# Professional Theme
theme_set(theme_minimal(base_size = 14) +
theme(plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
plot.subtitle = element_text(size = 12, color = "grey40"),
legend.position = "top"))
# 2. DATA LOADING & PREP -------------------------------------------------------
load_music_file <- function(filename) {
readr::read_delim(filename, delim = ",", quote = "", comment = "",
na = c("", "NA", "-"), trim_ws = TRUE, show_col_types = FALSE)
}
if(file.exists("data_raw/song_chart.csv")) {
df_chart <- load_music_file("data_raw/song_chart.csv")
df_pop   <- load_music_file("data_raw/song_pop.csv")
df_audio <- load_music_file("data_raw/acoustic_features.csv")
} else { stop("ERROR: 'data_raw' folder missing.") }
# Normalisation Helper
min_max <- function(x) (x - min(x, na.rm=T)) / (max(x, na.rm=T) - min(x, na.rm=T))
message("STEP 1: Calculating Song Metrics...")
# CALCULATE 'WEEKS ON CHART' (Longevity)
song_longevity <- df_chart %>%
group_by(song_id) %>%
summarise(
Weeks_Charted = n(),             # How long it survived
Peak_Pos = min(peak_position, na.rm=T), # Best rank (1 is best)
First_Week = min(as.Date(week))  # Release date proxy
) %>%
mutate(Year = year(First_Week)) %>%
filter(Year >= 2000 & Year <= 2018)
# ==============================================================================
# Module: IJC437 Introduction to Data Science
# Coursework: The Mechanics of Musical Success (DISTINCTION PATH)
# Student ID: 25196971
# ==============================================================================
graphics.off()
rm(list = ls())
# 1. SETUP & LIBRARIES ---------------------------------------------------------
pkgs <- c("tidyverse", "scales", "broom", "lubridate", "patchwork")
to_install <- pkgs[!sapply(pkgs, require, character.only = TRUE)]
if(length(to_install) > 0) install.packages(to_install)
library(tidyverse)
library(scales)
library(broom)
library(lubridate)
library(patchwork)
set.seed(2026)
if (!dir.exists("plots_final")) dir.create("plots_final")
# Professional Theme
theme_set(theme_minimal(base_size = 14) +
theme(plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
plot.subtitle = element_text(size = 12, color = "grey40"),
legend.position = "top"))
# 2. DATA LOADING & PREP -------------------------------------------------------
load_music_file <- function(filename) {
readr::read_delim(filename, delim = ",", quote = "", comment = "",
na = c("", "NA", "-"), trim_ws = TRUE, show_col_types = FALSE)
}
if(file.exists("data_raw/song_chart.csv")) {
df_chart <- load_music_file("data_raw/song_chart.csv")
df_pop   <- load_music_file("data_raw/song_pop.csv")
df_audio <- load_music_file("data_raw/acoustic_features.csv")
} else { stop("ERROR: 'data_raw' folder missing.") }
# Normalisation Helper
min_max <- function(x) (x - min(x, na.rm=T)) / (max(x, na.rm=T) - min(x, na.rm=T))
message("STEP 1: Calculating Song Metrics...")
# CALCULATE 'WEEKS ON CHART' (Longevity)
song_longevity <- df_chart %>%
group_by(song_id) %>%
summarise(
Weeks_Charted = n(),             # How long it survived
Peak_Pos = min(peak_position, na.rm=T), # Best rank (1 is best)
First_Week = min(as.Date(week))  # Release date proxy
) %>%
mutate(Year = year(First_Week)) %>%
filter(Year >= 2000 & Year <= 2018)
# ==============================================================================
# RQ1: THE ERA COMPARISON
# Question: Do songs from Period A (2000-2009) differ from Period B (2010-2018)?
# Hypothesis: The Streaming Era (Period B) is statistically 'sadder' (Lower Valence).
# ==============================================================================
message("Generating RQ1 (Period A vs Period B)...")
# 1. Define the Periods
df_eras <- df_audio %>%
inner_join(df_pop, by = "song_id") %>%
mutate(Year = as.numeric(str_sub(week, 1, 4))) %>% # Extract Year
filter(Year >= 2000 & Year <= 2018) %>%
mutate(Period = ifelse(Year < 2010, "Period A (2000-2009)", "Period B (2010-2018)")) %>%
drop_na(valence, Period)
# ==============================================================================
# RQ1: THE ERA COMPARISON
# Question: Do songs from Period A (2000-2009) differ from Period B (2010-2018)?
# Hypothesis: The Streaming Era (Period B) is statistically 'sadder' (Lower Valence).
# ==============================================================================
message("Generating RQ1 (Period A vs Period B)...")
# 1. Define the Periods
df_eras <- df_audio %>%
inner_join(df_pop, by = "song_id") %>%
mutate(Year = as.numeric(str_sub(week, 1, 4))) %>% # Extract Year
filter(Year >= 2000 & Year <= 2018) %>%
mutate(Period = ifelse(Year < 2010, "Period A (2000-2009)", "Period B (2010-2018)")) %>%
drop_na(valence, Period)
# ==============================================================================
# Module: IJC437 Introduction to Data Science
# Coursework: The Evolution of Pop (Period A vs Period B)
# Student ID: 25196971
# ==============================================================================
graphics.off()
rm(list = ls())
# 1. SETUP & LIBRARIES ---------------------------------------------------------
pkgs <- c("tidyverse", "scales", "broom", "patchwork", "lubridate")
to_install <- pkgs[!sapply(pkgs, require, character.only = TRUE)]
if(length(to_install) > 0) install.packages(to_install)
library(tidyverse)
library(scales)
library(broom)
library(patchwork)
library(lubridate)
set.seed(2026)
if (!dir.exists("plots_final")) dir.create("plots_final")
# Professional Theme
theme_set(theme_minimal(base_size = 14) +
theme(plot.title = element_text(face = "bold", size = 16, color = "#2c3e50"),
plot.subtitle = element_text(size = 12, color = "grey40"),
legend.position = "top"))
# 2. DATA LOADING & AUTOMATIC FIX ----------------------------------------------
message("STEP 1: Loading Data...")
# Helper to read CSV safely
read_safe <- function(path) {
read_delim(path, delim = ",", quote = "", comment = "",
na = c("", "NA", "-"), trim_ws = TRUE, show_col_types = FALSE)
}
if(file.exists("data_raw/song_chart.csv")) {
df_chart <- read_safe("data_raw/song_chart.csv")
df_pop   <- read_safe("data_raw/song_pop.csv")
df_audio <- read_safe("data_raw/acoustic_features.csv")
} else { stop("ERROR: 'data_raw' folder missing.") }
# --- SAFETY FIX: Ensure 'song_id' exists ---
# If df_audio has 'id' but not 'song_id', rename it.
if ("id" %in% names(df_audio) && !"song_id" %in% names(df_audio)) {
df_audio <- df_audio %>% rename(song_id = id)
message("Fixed: Renamed 'id' to 'song_id' in df_audio.")
}
# --- SAFETY FIX: Ensure 'week' is Date format ---
# Sometimes 'week' loads as text. We fix it here once for everyone.
df_chart <- df_chart %>%
mutate(week = as.Date(week)) %>%
drop_na(week)
